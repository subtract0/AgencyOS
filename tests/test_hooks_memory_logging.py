"""
Tests for Memory API integration with system hooks.

These tests verify that the MemoryIntegrationHook properly stores
memory records during agent lifecycle events and tool invocations.
"""

# Import the modules we're testing
import sys
import tempfile
from datetime import datetime
from unittest.mock import MagicMock, patch

import pytest

sys.path.append("/Users/am/Code/Agency")

from agency_memory import InMemoryStore, Memory
from shared.agent_context import AgentContext, create_agent_context
from shared.system_hooks import MemoryIntegrationHook, create_memory_integration_hook


class MockTool:
    """Mock tool for testing."""

    def __init__(self, name="test_tool", parameters=None):
        self.name = name
        self.parameters = parameters or {"param1": "value1", "param2": "value2"}


class MockAgent:
    """Mock agent for testing."""

    def __init__(self, name="TestAgent"):
        self.__class__.__name__ = name


class MockContext:
    """Mock RunContextWrapper for testing."""

    def __init__(self, context_id="test_context"):
        self.id = context_id
        self.context = MagicMock()


@pytest.fixture
def memory_store():
    """Create a fresh in-memory store for each test."""
    return InMemoryStore()


@pytest.fixture
def memory_instance(memory_store):
    """Create a Memory instance with the test store."""
    return Memory(store=memory_store)


@pytest.fixture
def agent_context(memory_instance):
    """Create an AgentContext for testing."""
    return create_agent_context(memory=memory_instance, session_id="test_session_123")


@pytest.fixture
def memory_hook(agent_context):
    """Create a MemoryIntegrationHook for testing."""
    return MemoryIntegrationHook(agent_context=agent_context)


@pytest.fixture
def mock_agent():
    """Create a mock agent."""
    return MockAgent("TestAgent")


@pytest.fixture
def mock_context():
    """Create a mock context."""
    return MockContext("test_context_123")


@pytest.fixture
def mock_tool():
    """Create a mock tool."""
    return MockTool("TestTool", {"file_path": "/test/path", "content": "test content"})


class TestMemoryIntegrationHook:
    """Test the MemoryIntegrationHook class."""

    def test_hook_initialization(self, agent_context):
        """Test that hook initializes properly."""
        hook = MemoryIntegrationHook(agent_context=agent_context)

        assert hook.agent_context == agent_context
        assert hook.session_start_time is None
        assert hook.agent_context.session_id == "test_session_123"

    def test_hook_initialization_without_context(self):
        """Test that hook creates default context when none provided."""
        hook = MemoryIntegrationHook()

        assert hook.agent_context is not None
        assert isinstance(hook.agent_context, AgentContext)
        assert hook.agent_context.session_id.startswith("session_")

    @pytest.mark.asyncio
    async def test_on_start_stores_session_start(self, memory_hook, mock_agent, mock_context):
        """Test that on_start stores session start memory."""
        # Call the hook
        await memory_hook.on_start(mock_context, mock_agent)

        # Verify memory was stored
        memories = memory_hook.agent_context.search_memories(["session", "start"])
        assert len(memories) == 1

        memory = memories[0]
        assert "session_start_" in memory["key"]
        expected_tags = ["session", "start", "session:test_session_123"]
        assert set(memory["tags"]) == set(expected_tags)

        content = memory["content"]
        assert content["agent_type"] == "TestAgent"
        assert content["context_id"] == "test_context_123"
        assert "timestamp" in content

        # Verify session start time was recorded
        assert memory_hook.session_start_time is not None

    @pytest.mark.asyncio
    async def test_on_end_stores_session_end(self, memory_hook, mock_agent, mock_context):
        """Test that on_end stores session end memory."""
        # Set up a start time first
        memory_hook.session_start_time = datetime.now().isoformat()

        # Mock the transcript generation to avoid file system operations
        with patch.object(memory_hook, "_generate_session_transcript") as mock_transcript:
            mock_transcript.return_value = None

            # Call the hook
            output = {"result": "test output", "status": "success"}
            await memory_hook.on_end(mock_context, mock_agent, output)

        # Verify memory was stored
        memories = memory_hook.agent_context.search_memories(["session", "end"])
        assert len(memories) == 1

        memory = memories[0]
        assert "session_end_" in memory["key"]
        expected_tags = ["session", "end", "session:test_session_123"]
        assert set(memory["tags"]) == set(expected_tags)

        content = memory["content"]
        assert content["agent_type"] == "TestAgent"
        assert "session_duration" in content
        assert "output_summary" in content

        # Verify transcript generation was called
        mock_transcript.assert_called_once()

    @pytest.mark.asyncio
    async def test_on_tool_start_stores_tool_call(
        self, memory_hook, mock_agent, mock_context, mock_tool
    ):
        """Test that on_tool_start stores tool call memory."""
        await memory_hook.on_tool_start(mock_context, mock_agent, mock_tool)

        # Verify memory was stored
        memories = memory_hook.agent_context.search_memories(["tool", "TestTool", "call"])
        assert len(memories) == 1

        memory = memories[0]
        assert "tool_call_TestTool_" in memory["key"]
        assert "tool" in memory["tags"]
        assert "TestTool" in memory["tags"]
        assert "call" in memory["tags"]

        content = memory["content"]
        assert content["tool_name"] == "TestTool"
        assert content["agent_type"] == "TestAgent"
        assert "tool_parameters" in content
        assert content["tool_parameters"]["file_path"] == "/test/path"

    @pytest.mark.asyncio
    async def test_on_tool_end_stores_tool_result(
        self, memory_hook, mock_agent, mock_context, mock_tool
    ):
        """Test that on_tool_end stores tool result memory."""
        result = "This is a test tool result with some content"

        await memory_hook.on_tool_end(mock_context, mock_agent, mock_tool, result)

        # Verify memory was stored
        memories = memory_hook.agent_context.search_memories(["tool", "TestTool", "result"])
        assert len(memories) == 1

        memory = memories[0]
        assert "tool_result_TestTool_" in memory["key"]
        assert "tool" in memory["tags"]
        assert "TestTool" in memory["tags"]
        assert "result" in memory["tags"]

        content = memory["content"]
        assert content["tool_name"] == "TestTool"
        assert content["agent_type"] == "TestAgent"
        assert content["result"] == result
        assert content["result_size"] == len(result)

    @pytest.mark.asyncio
    async def test_tool_result_truncation(self, memory_hook, mock_agent, mock_context, mock_tool):
        """Test that large tool results are properly truncated."""
        # Create a large result (> 1000 chars)
        large_result = "x" * 1500

        await memory_hook.on_tool_end(mock_context, mock_agent, mock_tool, large_result)

        # Verify truncation occurred
        memories = memory_hook.agent_context.search_memories(["tool", "TestTool", "result"])
        memory = memories[0]

        content = memory["content"]
        assert len(content["result"]) == 1013  # 1000 + "...[truncated]"
        assert content["result"].endswith("...[truncated]")
        assert content["result_size"] == 1500  # Original size is preserved

    @pytest.mark.asyncio
    async def test_tool_parameter_sanitization(self, memory_hook, mock_agent, mock_context):
        """Test that sensitive tool parameters are redacted."""
        sensitive_tool = MockTool(
            "SensitiveTool",
            {
                "file_path": "/test/path",
                "password": "secret123",
                "api_key": "key123",
                "token": "token123",
            },
        )

        await memory_hook.on_tool_start(mock_context, mock_agent, sensitive_tool)

        memories = memory_hook.agent_context.search_memories(["tool", "SensitiveTool", "call"])
        memory = memories[0]

        params = memory["content"]["tool_parameters"]
        assert params["file_path"] == "/test/path"
        assert params["password"] == "[REDACTED]"
        assert params["api_key"] == "[REDACTED]"
        assert params["token"] == "[REDACTED]"

    @pytest.mark.asyncio
    async def test_error_handling_in_tool_end(
        self, memory_hook, mock_agent, mock_context, mock_tool
    ):
        """Test error handling when tool_end fails."""
        # Force an error by making agent_context None
        original_context = memory_hook.agent_context
        memory_hook.agent_context = None

        # This should not raise an exception
        await memory_hook.on_tool_end(mock_context, mock_agent, mock_tool, "test result")

        # Restore context
        memory_hook.agent_context = original_context

    def test_content_truncation(self, memory_hook):
        """Test the _truncate_content helper method."""
        # Test normal content
        assert memory_hook._truncate_content("short", 10) == "short"

        # Test content that needs truncation
        result = memory_hook._truncate_content("this is a long string", 10)
        assert result == "this is a ...[truncated]"

        # Test empty content
        assert memory_hook._truncate_content("", 10) == ""
        assert memory_hook._truncate_content(None, 10) == ""

    def test_session_duration_calculation(self, memory_hook):
        """Test session duration calculation."""
        # Test without start time
        assert memory_hook._calculate_session_duration() is None

        # Test with start time
        memory_hook.session_start_time = datetime.now().isoformat()
        duration = memory_hook._calculate_session_duration()
        assert duration is not None
        assert isinstance(duration, str)

    @pytest.mark.asyncio
    async def test_handoff_memory_storage(self, memory_hook, mock_context):
        """Test that handoff events are properly stored."""
        source_agent = MockAgent("SourceAgent")
        target_agent = MockAgent("TargetAgent")

        await memory_hook.on_handoff(mock_context, target_agent, source_agent)

        memories = memory_hook.agent_context.search_memories(["handoff"])
        assert len(memories) == 1

        memory = memories[0]
        assert "handoff_" in memory["key"]
        assert "handoff" in memory["tags"]
        assert "agent_transfer" in memory["tags"]

        content = memory["content"]
        assert content["target_agent"] == "TargetAgent"
        assert content["source_agent"] == "SourceAgent"


class TestFactoryFunctions:
    """Test the factory functions."""

    def test_create_memory_integration_hook_default(self):
        """Test creating hook with default context."""
        hook = create_memory_integration_hook()

        assert isinstance(hook, MemoryIntegrationHook)
        assert isinstance(hook.agent_context, AgentContext)
        assert hook.agent_context.session_id.startswith("session_")

    def test_create_memory_integration_hook_with_context(self, agent_context):
        """Test creating hook with provided context."""
        hook = create_memory_integration_hook(agent_context)

        assert isinstance(hook, MemoryIntegrationHook)
        assert hook.agent_context == agent_context
        assert hook.agent_context.session_id == "test_session_123"


class TestIntegrationScenarios:
    """Test complete agent/tool flow scenarios."""

    @pytest.mark.asyncio
    async def test_complete_session_flow(self, memory_hook, mock_agent, mock_context, mock_tool):
        """Test a complete session with multiple tool calls."""
        # Session start
        await memory_hook.on_start(mock_context, mock_agent)

        # Tool call 1
        await memory_hook.on_tool_start(mock_context, mock_agent, mock_tool)
        await memory_hook.on_tool_end(mock_context, mock_agent, mock_tool, "Result 1")

        # Tool call 2
        tool2 = MockTool("SecondTool")
        await memory_hook.on_tool_start(mock_context, mock_agent, tool2)
        await memory_hook.on_tool_end(mock_context, mock_agent, tool2, "Result 2")

        # Session end
        with patch.object(memory_hook, "_generate_session_transcript"):
            await memory_hook.on_end(mock_context, mock_agent, {"status": "complete"})

        # Verify all memories were stored
        all_memories = memory_hook.agent_context.get_session_memories()
        assert len(all_memories) == 6  # start + 2*(tool_start + tool_end) + end

        # Verify we have the right types
        memory_types = []
        for memory in all_memories:
            if "session_start" in memory["key"]:
                memory_types.append("session_start")
            elif "session_end" in memory["key"]:
                memory_types.append("session_end")
            elif "tool_call" in memory["key"]:
                memory_types.append("tool_call")
            elif "tool_result" in memory["key"]:
                memory_types.append("tool_result")

        assert "session_start" in memory_types
        assert "session_end" in memory_types
        assert memory_types.count("tool_call") == 2
        assert memory_types.count("tool_result") == 2

    @pytest.mark.asyncio
    async def test_transcript_generation(self, memory_hook):
        """Test that session transcript is properly generated."""
        # Add some test memories
        memory_hook.agent_context.store_memory("test1", {"data": "test1"}, ["test"])
        memory_hook.agent_context.store_memory("test2", {"data": "test2"}, ["test"])

        # Create a temporary directory for testing
        with tempfile.TemporaryDirectory() as temp_dir:
            # Patch the transcript directory
            with patch("shared.system_hooks.create_session_transcript") as mock_create:
                mock_create.return_value = f"{temp_dir}/test_transcript.md"

                await memory_hook._generate_session_transcript()

                # Check if transcript creation was called (might not be in CI)
                if mock_create.called:
                    # Verify transcript creation was called with session memories
                    args = mock_create.call_args[0]
                    session_memories = args[0]
                    session_id = args[1]

                    assert session_id == memory_hook.agent_context.session_id
                    assert len(session_memories) >= 2  # Our test memories
                else:
                    # In CI environments, the method may fail silently due to filesystem restrictions
                    pytest.skip(
                        "Transcript generation skipped - likely due to filesystem restrictions in CI"
                    )

    def test_memory_search_functionality(self, memory_hook):
        """Test that memory search works correctly with session tags."""
        # Store some memories
        memory_hook.agent_context.store_memory("tool1", {"tool": "test"}, ["tool", "call"])
        memory_hook.agent_context.store_memory("error1", {"error": "failed"}, ["error", "tool"])

        # Search for tool memories
        tool_memories = memory_hook.agent_context.search_memories(["tool"])
        assert len(tool_memories) == 1
        assert "tool1" == tool_memories[0]["key"]

        # Search for error memories
        error_memories = memory_hook.agent_context.search_memories(["error"])
        assert len(error_memories) == 1
        assert "error1" == error_memories[0]["key"]

        # Search for non-existent tag
        none_memories = memory_hook.agent_context.search_memories(["nonexistent"])
        assert len(none_memories) == 0


if __name__ == "__main__":
    # Run basic tests if executed directly
    print("Running basic memory integration tests...")

    # Test factory function
    hook = create_memory_integration_hook()
    print(f"✓ Hook created with session: {hook.agent_context.session_id}")

    # Test memory storage
    hook.agent_context.store_memory("test_key", {"test": "data"}, ["test"])
    memories = hook.agent_context.search_memories(["test"])
    print(f"✓ Memory stored and retrieved: {len(memories)} records")

    print("Basic tests passed! Run with pytest for comprehensive testing.")

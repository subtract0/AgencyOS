"""
Comprehensive unit tests for autonomous trigger system.

Tests the EventRouter, HealingTrigger, and PatternMatcher classes from
learning_loop.autonomous_triggers following NECESSARY pattern requirements.

Constitutional Compliance:
- Article I: Complete test coverage of all components
- Article II: 100% test verification required before integration
- Article III: Automated quality enforcement through testing
- Article IV: Testing learning integration patterns
- Article V: Spec-driven test implementation per SPEC-LEARNING-001
"""

import asyncio
from datetime import datetime, timedelta
from unittest.mock import AsyncMock, Mock, patch

import pytest

from learning_loop.autonomous_triggers import (
    EventRouter,
    HealingResult,
    HealingTrigger,
    PatternMatch,
    PatternMatcher,
    Response,
)
from learning_loop.event_detection import ErrorEvent, Event, FileEvent
from learning_loop.pattern_extraction import (
    EnhancedPattern,
    ErrorTrigger,
    PatternMetadata,
    TaskTrigger,
)


class TestEventRouter:
    """Test EventRouter class following NECESSARY pattern."""

    @pytest.fixture
    def mock_pattern_store(self):
        """Mock pattern store for testing."""
        store = Mock()
        store.find = Mock(return_value=[])
        store.search_patterns = Mock(return_value=[])
        store.store_pattern = Mock(return_value="pattern_id")
        store.get_pattern = Mock(return_value=None)
        return store

    @pytest.fixture
    def event_router(self, mock_pattern_store):
        """Create EventRouter instance for testing."""
        with patch(
            "learning_loop.autonomous_triggers.PatternStore", return_value=mock_pattern_store
        ):
            with patch("learning_loop.autonomous_triggers.get_telemetry") as mock_telemetry:
                mock_telemetry.return_value = Mock()
                router = EventRouter(mock_pattern_store)
                return router

    @pytest.fixture
    def sample_error_event(self):
        """Sample error event for testing."""
        return ErrorEvent(
            type="error_detected",
            timestamp=datetime.now(),
            error_type="NoneType",
            message="AttributeError: 'NoneType' object has no attribute 'test'",
            context="test context",
            source_file="test_file.py",
            line_number=42,
            metadata={},
        )

    @pytest.fixture
    def sample_file_event(self):
        """Sample file event for testing."""
        return FileEvent(
            type="file_modified",
            timestamp=datetime.now(),
            path="/test/file.py",
            change_type="modified",
            file_type="python",
            metadata={},
        )

    # N - No Missing Behaviors
    @pytest.mark.unit
    @pytest.mark.asyncio
    async def test_route_event_with_pattern_match(self, event_router, sample_error_event):
        """Test routing event when patterns match."""
        # Setup pattern match
        mock_pattern = Mock()
        mock_pattern_match = Mock()
        mock_pattern_match.pattern = mock_pattern
        mock_pattern_match.score = 0.8
        mock_pattern_match.confidence = 0.9

        event_router.pattern_matcher.find_matches = Mock(return_value=[mock_pattern_match])
        event_router.handlers["pattern_matched"].handle = AsyncMock(
            return_value=Response(success=True, handler_name="PatternApplicationHandler")
        )

        result = await event_router.route_event(sample_error_event)

        assert result.success is True
        assert result.handler_name == "PatternApplicationHandler"
        event_router.pattern_matcher.find_matches.assert_called_once_with(sample_error_event)

    @pytest.mark.unit
    @pytest.mark.asyncio
    async def test_route_event_by_type_no_patterns(self, event_router, sample_error_event):
        """Test routing event by type when no patterns match."""
        event_router.pattern_matcher.find_matches = Mock(return_value=[])
        event_router.handlers["error_detected"].handle = AsyncMock(
            return_value=Response(success=True, handler_name="ErrorHandler")
        )

        result = await event_router.route_event(sample_error_event)

        assert result.success is True
        assert result.handler_name == "ErrorHandler"

    @pytest.mark.unit
    @pytest.mark.asyncio
    async def test_route_event_unhandled_type(self, event_router):
        """Test routing event with unhandled type."""
        unknown_event = Event(type="unknown_type", timestamp=datetime.now(), metadata={})

        event_router.pattern_matcher.find_matches = Mock(return_value=[])

        result = await event_router.route_event(unknown_event)

        assert result.success is False
        assert result.handler_name == "NoHandler"
        assert "No handler found" in result.error

    # E - Edge Cases
    @pytest.mark.unit
    @pytest.mark.asyncio
    async def test_route_event_handler_exception(self, event_router, sample_error_event):
        """Test routing when handler raises exception."""
        event_router.pattern_matcher.find_matches = Mock(return_value=[])
        event_router.handlers["error_detected"].handle = AsyncMock(
            side_effect=Exception("Handler error")
        )

        result = await event_router.route_event(sample_error_event)

        assert result.success is False
        assert result.handler_name == "RouterError"
        assert "Handler error" in result.error

    @pytest.mark.unit
    @pytest.mark.asyncio
    async def test_route_event_pattern_matcher_exception(self, event_router, sample_error_event):
        """Test routing when pattern matcher raises exception."""
        event_router.pattern_matcher.find_matches = Mock(side_effect=Exception("Pattern error"))

        result = await event_router.route_event(sample_error_event)

        assert result.success is False
        assert result.handler_name == "RouterError"
        assert "Pattern error" in result.error

    # C - Comprehensive
    @pytest.mark.unit
    @pytest.mark.asyncio
    async def test_route_file_events(self, event_router, sample_file_event):
        """Test routing file modification events."""
        event_router.pattern_matcher.find_matches = Mock(return_value=[])
        event_router.handlers["file_modified"].handle = AsyncMock(
            return_value=Response(success=True, handler_name="ChangeHandler")
        )

        result = await event_router.route_event(sample_file_event)

        assert result.success is True
        assert result.handler_name == "ChangeHandler"

    @pytest.mark.unit
    def test_initialization_handlers_setup(self, event_router):
        """Test that all required handlers are initialized."""
        assert "error_detected" in event_router.handlers
        assert "test_failure" in event_router.handlers
        assert "file_modified" in event_router.handlers
        assert "pattern_matched" in event_router.handlers

        # Verify healing trigger wiring
        assert event_router.error_handler.healing_trigger is not None
        assert event_router.error_handler.healing_trigger == event_router.healing_trigger

    # E - Error Conditions
    @pytest.mark.unit
    @pytest.mark.asyncio
    async def test_route_event_none_event(self, event_router):
        """Test routing with None event."""
        with pytest.raises(AttributeError):
            await event_router.route_event(None)

    # S - State Validation
    @pytest.mark.unit
    def test_router_state_after_initialization(self, event_router, mock_pattern_store):
        """Test router state is correctly initialized."""
        assert event_router.pattern_store == mock_pattern_store
        assert event_router.pattern_matcher is not None
        assert event_router.healing_trigger is not None
        assert (
            len(event_router.handlers) == 5
        )  # error_detected, test_failure, file_modified, file_created, pattern_matched

    # S - Side Effects
    @pytest.mark.unit
    @pytest.mark.asyncio
    async def test_telemetry_emissions_on_routing(self, event_router, sample_error_event):
        """Test telemetry events are emitted during routing."""
        event_router.pattern_matcher.find_matches = Mock(return_value=[])
        event_router.handlers["error_detected"].handle = AsyncMock(
            return_value=Response(success=True, handler_name="ErrorHandler")
        )

        await event_router.route_event(sample_error_event)

        # Verify telemetry calls (mocked through emit calls)
        # This would be verified through telemetry mock assertions in real implementation


class TestHealingTrigger:
    """Test HealingTrigger class following NECESSARY pattern."""

    @pytest.fixture
    def mock_pattern_store(self):
        """Mock pattern store for testing."""
        store = Mock()
        store.find = Mock(return_value=[])
        store.search_patterns = Mock(return_value=[])
        store.store_pattern = Mock(return_value="pattern_id")
        store.get_pattern = Mock(return_value=None)
        return store

    @pytest.fixture
    def mock_healing_core(self):
        """Mock self-healing core for testing."""
        core = Mock()
        core.fix_error.return_value = True
        return core

    @pytest.fixture
    def healing_trigger(self, mock_pattern_store, mock_healing_core):
        """Create HealingTrigger instance for testing."""
        with patch(
            "learning_loop.autonomous_triggers.PatternStore", return_value=mock_pattern_store
        ):
            with patch(
                "learning_loop.autonomous_triggers.SelfHealingCore", return_value=mock_healing_core
            ):
                with patch("learning_loop.autonomous_triggers.get_telemetry") as mock_telemetry:
                    mock_telemetry.return_value = Mock()
                    trigger = HealingTrigger(mock_pattern_store)
                    return trigger

    @pytest.fixture
    def sample_error_event(self):
        """Sample error event for testing."""
        return ErrorEvent(
            type="error_detected",
            timestamp=datetime.now(),
            error_type="NoneType",
            message="AttributeError: 'NoneType' object has no attribute 'test'",
            context="test context",
            source_file="test_file.py",
            line_number=42,
            metadata={},
        )

    # N - No Missing Behaviors
    @pytest.mark.unit
    @pytest.mark.asyncio
    async def test_handle_error_successful_generic_healing(
        self, healing_trigger, sample_error_event
    ):
        """Test successful generic healing when no patterns match."""
        healing_trigger._find_pattern_for_error = Mock(return_value=None)
        healing_trigger.healing_core.fix_error.return_value = True

        result = await healing_trigger.handle_error(sample_error_event)

        assert result.success is True
        assert result.skipped is False
        assert "Generic healing applied" in result.reason

    @pytest.mark.unit
    @pytest.mark.asyncio
    async def test_handle_error_with_pattern(self, healing_trigger, sample_error_event):
        """Test healing with known pattern."""
        mock_pattern = Mock()
        mock_pattern.id = "test_pattern"
        healing_trigger._find_pattern_for_error = Mock(return_value=mock_pattern)
        healing_trigger.healing_core.fix_error.return_value = True

        result = await healing_trigger.handle_error(sample_error_event)

        assert result.success is True
        assert result.pattern_used == "test_pattern"

    @pytest.mark.unit
    @pytest.mark.asyncio
    async def test_handle_error_cooldown_active(self, healing_trigger, sample_error_event):
        """Test error handling when cooldown is active."""
        # Add error to cooldown
        key = f"{sample_error_event.error_type}:{sample_error_event.source_file}"
        healing_trigger.cooldown[key] = datetime.now()

        result = await healing_trigger.handle_error(sample_error_event)

        assert result.success is False
        assert result.skipped is True
        assert result.reason == "cooldown"

    # E - Edge Cases
    @pytest.mark.unit
    @pytest.mark.asyncio
    async def test_handle_error_healing_exception(self, healing_trigger, sample_error_event):
        """Test handling when healing core raises exception."""
        healing_trigger._find_pattern_for_error = Mock(return_value=None)
        healing_trigger.healing_core.fix_error.side_effect = Exception("Healing error")

        result = await healing_trigger.handle_error(sample_error_event)

        assert result.success is False
        assert "Healing error" in result.reason
        assert result.error_details == "Healing error"

    @pytest.mark.unit
    @pytest.mark.asyncio
    async def test_handle_error_no_source_file(self, healing_trigger):
        """Test handling error without source file."""
        error_event = ErrorEvent(
            type="error_detected",
            timestamp=datetime.now(),
            error_type="NoneType",
            message="Error message",
            context="context",
            source_file=None,
            metadata={},
        )

        healing_trigger._find_pattern_for_error = Mock(return_value=None)
        healing_trigger.healing_core.fix_error.return_value = True

        result = await healing_trigger.handle_error(error_event)

        assert result.success is True
        # Should handle None source_file gracefully

    # C - Comprehensive
    @pytest.mark.unit
    def test_cooldown_mechanism(self, healing_trigger, sample_error_event):
        """Test cooldown mechanism prevents repeated attempts."""
        # Test not in cooldown initially
        assert not healing_trigger._in_cooldown(sample_error_event)

        # Add to cooldown
        healing_trigger._add_cooldown(sample_error_event)

        # Test now in cooldown
        assert healing_trigger._in_cooldown(sample_error_event)

    @pytest.mark.unit
    def test_cooldown_expiry(self, healing_trigger, sample_error_event):
        """Test cooldown expires after specified time."""
        # Add to cooldown with past time
        key = f"{sample_error_event.error_type}:{sample_error_event.source_file}"
        healing_trigger.cooldown[key] = datetime.now() - timedelta(minutes=10)

        # Should not be in cooldown (expired)
        assert not healing_trigger._in_cooldown(sample_error_event)

    @pytest.mark.unit
    def test_find_pattern_for_error(self, healing_trigger, sample_error_event):
        """Test finding patterns for specific error types."""
        mock_patterns = [
            Mock(id="pattern1", success_rate=0.9),
            Mock(id="pattern2", success_rate=0.7),
        ]
        healing_trigger.pattern_store.find.return_value = mock_patterns

        result = healing_trigger._find_pattern_for_error(sample_error_event)

        assert result == mock_patterns[0]  # Highest success rate
        healing_trigger.pattern_store.find.assert_called_once_with(
            pattern_type="error_fix", tags=[sample_error_event.error_type]
        )

    # E - Error Conditions
    @pytest.mark.unit
    @pytest.mark.asyncio
    async def test_pattern_application_failure(self, healing_trigger, sample_error_event):
        """Test pattern application failure."""
        mock_pattern = Mock()
        mock_pattern.id = "test_pattern"
        healing_trigger._find_pattern_for_error = Mock(return_value=mock_pattern)
        healing_trigger.healing_core.fix_error.return_value = False

        result = await healing_trigger.handle_error(sample_error_event)

        assert result.success is False
        assert result.pattern_used == "test_pattern"
        assert "Pattern application failed" in result.reason

    # S - State Validation
    @pytest.mark.unit
    def test_initialization_state(self, healing_trigger, mock_pattern_store):
        """Test healing trigger initialization state."""
        assert healing_trigger.pattern_store == mock_pattern_store
        assert healing_trigger.cooldown == {}
        assert healing_trigger.cooldown_minutes == 5
        assert healing_trigger.healing_core is not None

    # S - Side Effects
    @pytest.mark.unit
    @pytest.mark.asyncio
    async def test_success_learning_integration(self, healing_trigger, sample_error_event):
        """Test success recording for learning integration."""
        healing_trigger._find_pattern_for_error = Mock(return_value=None)
        healing_trigger.healing_core.fix_error.return_value = True
        healing_trigger._record_success = Mock()

        result = await healing_trigger.handle_error(sample_error_event)

        assert result.success is True
        healing_trigger._record_success.assert_called_once()

    @pytest.mark.unit
    @pytest.mark.asyncio
    async def test_failure_learning_integration(self, healing_trigger, sample_error_event):
        """Test failure recording and cooldown addition."""
        healing_trigger._find_pattern_for_error = Mock(return_value=None)
        healing_trigger.healing_core.fix_error.return_value = False
        healing_trigger._record_failure = Mock()
        healing_trigger._add_cooldown = Mock()

        result = await healing_trigger.handle_error(sample_error_event)

        assert result.success is False
        healing_trigger._record_failure.assert_called_once()
        healing_trigger._add_cooldown.assert_called_once()

    # A - Async Operations
    @pytest.mark.unit
    @pytest.mark.asyncio
    async def test_concurrent_healing_attempts(self, healing_trigger, sample_error_event):
        """Test multiple concurrent healing attempts."""
        healing_trigger._find_pattern_for_error = Mock(return_value=None)
        healing_trigger.healing_core.fix_error.return_value = True

        # Create multiple concurrent healing attempts
        tasks = [healing_trigger.handle_error(sample_error_event) for _ in range(3)]

        results = await asyncio.gather(*tasks)

        # First should succeed, others should be in cooldown
        success_count = sum(1 for r in results if r.success)
        cooldown_count = sum(1 for r in results if r.skipped and r.reason == "cooldown")

        # At least one should succeed, others may be in cooldown due to timing
        assert success_count >= 1

    # R - Regression Prevention
    @pytest.mark.unit
    @pytest.mark.asyncio
    async def test_pattern_success_rate_update(self, healing_trigger, sample_error_event):
        """Test pattern success rate is updated after use."""
        mock_pattern = Mock()
        mock_pattern.id = "test_pattern"
        healing_trigger._find_pattern_for_error = Mock(return_value=mock_pattern)
        healing_trigger.healing_core.fix_error.return_value = True

        await healing_trigger.handle_error(sample_error_event)

        # Verify pattern store update was called
        healing_trigger.pattern_store.update_success_rate.assert_called_once_with(
            "test_pattern", True
        )

    # Y - Yielding Confidence
    @pytest.mark.unit
    def test_cooldown_key_generation(self, healing_trigger, sample_error_event):
        """Test cooldown key generation is consistent."""
        key1 = f"{sample_error_event.error_type}:{sample_error_event.source_file}"

        healing_trigger._add_cooldown(sample_error_event)

        assert key1 in healing_trigger.cooldown
        assert healing_trigger._in_cooldown(sample_error_event)


class TestPatternMatcher:
    """Test PatternMatcher class following NECESSARY pattern."""

    @pytest.fixture
    def mock_pattern_store(self):
        """Mock pattern store with sample patterns."""
        store = Mock()  # Don't restrict to PatternStore spec since we need find() method

        # Sample patterns for testing (using mock objects since Pattern interface changed)
        pattern1 = Mock()
        pattern1.id = "pattern1"
        pattern1.pattern_type = "error_fix"
        pattern1.context = {"error_type": "NoneType"}
        pattern1.solution = "Add null check"
        pattern1.success_rate = 0.9
        pattern1.usage_count = 5
        pattern1.created_at = datetime.now().isoformat()
        pattern1.last_used = datetime.now().isoformat()
        pattern1.tags = ["NoneType", "auto_learned"]

        pattern2 = Mock()
        pattern2.id = "pattern2"
        pattern2.pattern_type = "error_fix"
        pattern2.context = {"error_type": "ImportError"}
        pattern2.solution = "Fix import"
        pattern2.success_rate = 0.7
        pattern2.usage_count = 3
        pattern2.created_at = datetime.now().isoformat()
        pattern2.last_used = (datetime.now() - timedelta(days=10)).isoformat()
        pattern2.tags = ["ImportError", "auto_learned"]

        sample_patterns = [pattern1, pattern2]

        store.find.return_value = sample_patterns
        return store

    @pytest.fixture
    def pattern_matcher(self, mock_pattern_store):
        """Create PatternMatcher instance for testing."""
        with patch(
            "learning_loop.autonomous_triggers.PatternStore", return_value=mock_pattern_store
        ):
            with patch("learning_loop.autonomous_triggers.get_telemetry") as mock_telemetry:
                mock_telemetry.return_value = Mock()
                matcher = PatternMatcher(mock_pattern_store)
                return matcher

    @pytest.fixture
    def sample_error_event(self):
        """Sample error event for testing."""
        return ErrorEvent(
            type="error_detected",
            timestamp=datetime.now(),
            error_type="NoneType",
            message="AttributeError: 'NoneType' object has no attribute 'test'",
            context="test context",
            source_file="test_file.py",
            line_number=42,
            metadata={},
        )

    # N - No Missing Behaviors
    @pytest.mark.unit
    def test_find_matches_basic(self, pattern_matcher, sample_error_event):
        """Test basic pattern matching functionality."""
        matches = pattern_matcher.find_matches(sample_error_event)

        # Should find at least one match for NoneType error
        assert len(matches) > 0
        assert all(isinstance(m, PatternMatch) for m in matches)
        assert all(m.score <= 1.0 for m in matches)

    @pytest.mark.unit
    def test_find_matches_sorting(self, pattern_matcher, sample_error_event):
        """Test matches are sorted by score."""
        matches = pattern_matcher.find_matches(sample_error_event)

        if len(matches) > 1:
            # Verify descending score order
            for i in range(len(matches) - 1):
                assert matches[i].score >= matches[i + 1].score

    @pytest.mark.unit
    def test_calculate_similarity_error_type_match(self, pattern_matcher, sample_error_event):
        """Test similarity calculation with exact error type match."""
        # Create enhanced pattern with matching error type

        trigger = ErrorTrigger("NoneType", "AttributeError.*NoneType.*")
        metadata = PatternMetadata(
            confidence=0.9,
            usage_count=5,
            success_count=4,
            failure_count=1,
            last_used=datetime.now(),
            created_at=datetime.now(),
            source="learned",
            tags=["NoneType"],
        )
        pattern = EnhancedPattern(
            id="test",
            trigger=trigger,
            preconditions=[],
            actions=[],
            postconditions=[],
            metadata=metadata,
        )

        similarity = pattern_matcher._calculate_similarity(sample_error_event, pattern)

        # Should have significant similarity due to error type match (0.4 weight)
        assert similarity >= 0.4

    # E - Edge Cases
    @pytest.mark.unit
    def test_find_matches_no_patterns(self, pattern_matcher, sample_error_event):
        """Test matching when no patterns exist."""
        pattern_matcher.pattern_store.find.return_value = []

        matches = pattern_matcher.find_matches(sample_error_event)

        assert len(matches) == 0

    @pytest.mark.unit
    def test_find_matches_low_confidence_filtered(self, pattern_matcher, sample_error_event):
        """Test that low confidence matches are filtered out."""
        # Create pattern with very low success rate (using mock)
        low_confidence_pattern = Mock()
        low_confidence_pattern.id = "low_pattern"
        low_confidence_pattern.pattern_type = "error_fix"
        low_confidence_pattern.context = {"error_type": "NoneType"}
        low_confidence_pattern.solution = "Low confidence fix"
        low_confidence_pattern.success_rate = 0.1  # Very low success rate
        low_confidence_pattern.usage_count = 1
        low_confidence_pattern.created_at = datetime.now().isoformat()
        low_confidence_pattern.last_used = datetime.now().isoformat()
        low_confidence_pattern.tags = ["NoneType"]

        pattern_matcher.pattern_store.find.return_value = [low_confidence_pattern]

        matches = pattern_matcher.find_matches(sample_error_event)

        # Should be filtered out due to low weighted score (0.1 * similarity < 0.3 threshold)
        assert len(matches) == 0

    # C - Comprehensive
    @pytest.mark.unit
    def test_similarity_factors_comprehensive(self, pattern_matcher, sample_error_event):
        """Test all similarity factors are considered."""

        # Create pattern that should match on multiple factors
        trigger = ErrorTrigger("NoneType", "AttributeError.*NoneType.*")
        metadata = PatternMetadata(
            confidence=0.9,
            usage_count=10,
            success_count=9,
            failure_count=1,
            last_used=datetime.now(),
            created_at=datetime.now(),
            source="learned",
            tags=["NoneType", "python", "test"],
        )
        pattern = EnhancedPattern(
            id="comprehensive_test",
            trigger=trigger,
            preconditions=[],
            actions=[],
            postconditions=[],
            metadata=metadata,
        )

        similarity = pattern_matcher._calculate_similarity(sample_error_event, pattern)

        # Should consider all factors: error type, file context, semantic, historical
        assert 0.0 <= similarity <= 1.0

    @pytest.mark.unit
    def test_semantic_similarity_calculation(self, pattern_matcher, sample_error_event):
        """Test semantic similarity calculation."""

        # Create pattern with overlapping keywords
        trigger = TaskTrigger(["test", "attribute", "error"])
        metadata = PatternMetadata(
            confidence=0.8,
            usage_count=3,
            success_count=2,
            failure_count=1,
            last_used=datetime.now(),
            created_at=datetime.now(),
            source="learned",
            tags=["test", "attribute"],
        )
        pattern = EnhancedPattern(
            id="semantic_test",
            trigger=trigger,
            preconditions=[],
            actions=[],
            postconditions=[],
            metadata=metadata,
        )

        similarity = pattern_matcher._semantic_similarity(sample_error_event, pattern)

        assert 0.0 <= similarity <= 1.0

    # E - Error Conditions
    @pytest.mark.unit
    def test_pattern_conversion_error_handling(self, pattern_matcher, sample_error_event):
        """Test handling of pattern conversion errors."""
        # Create malformed pattern (using mock)
        malformed_pattern = Mock()
        malformed_pattern.id = "malformed"
        malformed_pattern.pattern_type = "error_fix"
        malformed_pattern.context = {"error_type": "NoneType"}
        malformed_pattern.solution = "Fix"
        malformed_pattern.success_rate = 0.8
        malformed_pattern.usage_count = 1
        malformed_pattern.created_at = "invalid-date"  # Invalid date format
        malformed_pattern.last_used = "invalid-date"
        malformed_pattern.tags = ["NoneType"]

        pattern_matcher.pattern_store.find.return_value = [malformed_pattern]

        # Should handle conversion error gracefully
        matches = pattern_matcher.find_matches(sample_error_event)

        # May have 0 matches due to conversion error, but shouldn't crash
        assert isinstance(matches, list)

    # S - State Validation
    @pytest.mark.unit
    def test_initialization_state(self, pattern_matcher, mock_pattern_store):
        """Test pattern matcher initialization state."""
        assert pattern_matcher.pattern_store == mock_pattern_store
        assert pattern_matcher.min_threshold == 0.3
        assert pattern_matcher.telemetry is not None

    # S - Side Effects
    @pytest.mark.unit
    def test_confidence_calculation_factors(self, pattern_matcher):
        """Test confidence calculation considers multiple factors."""
        # High usage, recent pattern (using mock)
        recent_pattern = Mock()
        recent_pattern.id = "recent"
        recent_pattern.pattern_type = "error_fix"
        recent_pattern.context = {}
        recent_pattern.solution = "fix"
        recent_pattern.success_rate = 0.8
        recent_pattern.usage_count = 10  # High usage
        recent_pattern.created_at = datetime.now().isoformat()
        recent_pattern.last_used = datetime.now().isoformat()  # Recent use
        recent_pattern.tags = []

        confidence = pattern_matcher._calculate_confidence(recent_pattern, Mock())

        # Should boost confidence for high usage and recent use
        assert confidence >= 0.8

    # A - Async Operations (N/A for PatternMatcher - synchronous operations)

    # R - Regression Prevention
    @pytest.mark.unit
    def test_file_context_matching(self, pattern_matcher):
        """Test file context matching works correctly."""
        # Test event from test file
        test_event = ErrorEvent(
            type="error_detected",
            timestamp=datetime.now(),
            error_type="NoneType",
            message="Error in test",
            context="context",
            source_file="test_something.py",
            metadata={},
        )


        # Pattern with test-related tags
        trigger = ErrorTrigger("NoneType", ".*")
        metadata = PatternMetadata(
            confidence=0.8,
            usage_count=1,
            success_count=1,
            failure_count=0,
            last_used=datetime.now(),
            created_at=datetime.now(),
            source="learned",
            tags=["test", "uses_test"],
        )
        pattern = EnhancedPattern(
            id="test_pattern",
            trigger=trigger,
            preconditions=[],
            actions=[],
            postconditions=[],
            metadata=metadata,
        )

        has_similar_context = pattern_matcher._similar_file_context(test_event, pattern)

        assert has_similar_context is True

    # Y - Yielding Confidence
    @pytest.mark.unit
    def test_weighted_scoring_application(self, pattern_matcher, sample_error_event):
        """Test weighted scoring is applied correctly per spec."""
        matches = pattern_matcher.find_matches(sample_error_event)

        for match in matches:
            # Verify score is product of similarity and success rate
            assert match.score <= 1.0
            assert match.confidence >= 0.0


# Integration test for complete flow
class TestAutonomousTriggersIntegration:
    """Integration tests for autonomous triggers system."""

    @pytest.mark.unit
    @pytest.mark.asyncio
    async def test_complete_error_handling_flow(self):
        """Test complete flow from event to healing."""
        # Mock dependencies
        mock_pattern_store = Mock()  # Removed UnifiedPatternStore spec
        mock_pattern_store.find.return_value = []
        mock_healing_core = Mock()
        mock_healing_core.fix_error.return_value = True

        # Create error event
        error_event = ErrorEvent(
            type="error_detected",
            timestamp=datetime.now(),
            error_type="NoneType",
            message="AttributeError: 'NoneType' object has no attribute 'test'",
            context="test context",
            source_file="test_file.py",
            line_number=42,
            metadata={},
        )

        with patch(
            "learning_loop.autonomous_triggers.PatternStore", return_value=mock_pattern_store
        ):
            with patch(
                "learning_loop.autonomous_triggers.SelfHealingCore", return_value=mock_healing_core
            ):
                with patch("learning_loop.autonomous_triggers.get_telemetry") as mock_telemetry:
                    mock_telemetry.return_value = Mock()

                    # Create router
                    router = EventRouter(mock_pattern_store)

                    # Route event
                    response = await router.route_event(error_event)

                    # Verify successful healing
                    assert response.success is True
                    assert isinstance(response.result, HealingResult)

                    # Verify healing core was called
                    mock_healing_core.fix_error.assert_called_once()

    @pytest.mark.unit
    def test_system_initialization(self):
        """Test complete system initialization without errors."""
        mock_pattern_store = Mock()  # Removed UnifiedPatternStore spec
        mock_pattern_store.find.return_value = []

        with patch(
            "learning_loop.autonomous_triggers.PatternStore", return_value=mock_pattern_store
        ):
            with patch("learning_loop.autonomous_triggers.get_telemetry") as mock_telemetry:
                mock_telemetry.return_value = Mock()

                # Should initialize without errors
                router = EventRouter(mock_pattern_store)
                healing_trigger = HealingTrigger(mock_pattern_store)
                pattern_matcher = PatternMatcher(mock_pattern_store)

                # Verify all components initialized
                assert router is not None
                assert healing_trigger is not None
                assert pattern_matcher is not None


if __name__ == "__main__":
    # Run tests with verbose output
    pytest.main([__file__, "-v", "--tb=short"])
